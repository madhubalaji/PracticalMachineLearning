source('/coursera/RProgram/cacheMeanSample.R', echo=TRUE)
mytes(c(1,2,3,5))
source('/coursera/RProgram/ProgrammingAssignment2/cachematrix.R', echo=TRUE)
testf(mat9 = 1:4,2,2)
testf(mat9 = matrix(1:4,2,2))
source('/coursera/RProgram/ProgrammingAssignment2/cachematrix.R', echo=TRUE)
testf(mat9 = matrix(1:4,2,2))
testf(mat9 = matrix(1:4,2,2))
source('/coursera/RProgram/ProgrammingAssignment2/cachematrix.R', echo=TRUE)
testf(mat9 = matrix(1:4,2,2))
source('/coursera/RProgram/ProgrammingAssignment2/cachematrix.R', echo=TRUE)
testf(mat9 = matrix(1:4,2,2))
source('/coursera/RProgram/ProgrammingAssignment2/cachematrix.R', echo=TRUE)
source('/coursera/RProgram/ProgrammingAssignment2/cachematrix.R', echo=TRUE)
testf(mat9 = matrix(1:4,2,2))
testf(mat9 = matrix(1:4,2,2))
testf(mat9 = matrix(1:4,2,2))
print("getting cached data")
debugSource('/coursera/RProgram/ProgrammingAssignment2/cachematrix.R', echo=TRUE)
testf(mat9 = matrix(1:4,2,2))
testf(mat9 = matrix(1:4,2,2))
debugSource('/coursera/RProgram/ProgrammingAssignment2/cachematrix.R', echo=TRUE)
testf(mat9 = matrix(1:4,2,2))
debugSource('/coursera/RProgram/ProgrammingAssignment2/cachematrix.R', echo=TRUE)
testf(mat9 = matrix(1:4,2,2))
debugSource('/coursera/RProgram/ProgrammingAssignment2/cachematrix.R', echo=TRUE)
testf(mat9 = matrix(1:4,2,2))
testf(mat9 = matrix(1:4,2,2))
testf(mat9 = matrix(1:4,2,2))
source('/coursera/RProgram/ProgrammingAssignment2/cachematrix.R', echo=TRUE)
source('/coursera/RProgram/ProgrammingAssignment2/cachematrix.R', echo=TRUE)
source('/coursera/RProgram/ProgrammingAssignment2/cachematrix.R', echo=TRUE)
testf(mat9 = matrix(1:4,2,2))
source('/coursera/RProgram/ProgrammingAssignment2/cachematrix.R', echo=TRUE)
testf(mat9 = matrix(1:4,2,2))
source('/coursera/RProgram/ProgrammingAssignment2/cachematrix.R', echo=TRUE)
testf(mat9 = matrix(1:4,2,2))
source('/coursera/RProgram/ProgrammingAssignment2/cachematrix.R', echo=TRUE)
testf(mat9 = matrix(1:4,2,2))
source('/coursera/RProgram/ProgrammingAssignment2/cachematrix.R', echo=TRUE)
testf(mat9 = matrix(1:4,2,2))
source('/coursera/RProgram/ProgrammingAssignment2/cachematrix.R', echo=TRUE)
testf(mat9 = matrix(1:4,2,2))
add2 <- function(x,y) {
x+y
}
add2(-2,-4)
retVal <- function(x) {
use  <- x > 10
x[use]
}
retVal(c(23,33,1,34,3,9))
above <- function(x, i) {
val <- x > i
x[val]
}
above(c(22,44,20,4,2,99), 21)
above(c(22,44,20,4,2,99), 2)
above(c(22,44,20,4,2,99))
above <- function(x, i = 9) {
val <- x > i
x[val]
}
above(c(22,44,20,4,2,99))
colMean <- function(x, removeNA = TRUE) {
nc = ncol(x)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <- mean(x[,i])
}
means
}
x <- matrix(1:6, 1,6)
colMean(x)
x <- matrix(1:100, 10,10)
colMean(x)
x
colMean <- function(x, removeNA = TRUE) {
nc = ncol(x)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <- mean(x[,i], na.rm = removeNA)
}
means
}
colMean(x, FALSE)
plot(3,5,"l")
plot(3,5,"l",3)
plot(3,5,"c")
plot("Da","Ta","c")
plot("Da","Ta","l")
plot(10,10,"Da","Ta","l")
plot(10,10,"Da","Ta")
plot(10,10)
plot(10,10,"o")
plot(10,20,...)
plot(10,20,... = "l")
plot(...,10,20)
warnings()
plot.design(10,2,fun=mean(248.2))
plot.design(10,2,fun=mean)
plot.design(10,2+3,fun=mean)
plot.design(10*2,2+3,)
plot.design(10*2,2+3)
plot.design(10*2,2+3,"l")
plot()
help( (plot)
/
)
help("plot")
plot(10,10,... = par("ask"))
plot(3,5,"l")
search()
f <- function(x,y) {
zz
}
f(10,2)
f <- function(x,y) {
z
}
f(10,2)
f <- function(x,y) {
(x+y)z
}
f <- function(x,y) {
(x+y) * z
}
f(10,2)
z < 10
z <- 10
f(10,2)
f <- function(x,y) {
(x+y) * z2
}
f(10,2)
f <- function(x,y) {
(x+y) * nc
}
f(10,2)
colMean <- function(x, removeNA = TRUE) {
nc = ncol(x)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <- mean(x[,i], na.rm = removeNA)
}
means
}
f <- function(x,y) {
(x+y) * nc
}
f(10,2)
f <- function(x,y) {
(x+y) * i
}
f(10,2)
ls(environment(n))
ls(environment(x))
cube < make.power(2)
cube <- make.power(2)
f <- function(y) {
foo <- function(n) {
n^y
}
foo
}
l <- f(2)
foo(2)
foo(l)
cube <- f(3)
square <- f(2)
cube(2)
square(2)
ls(environment(cube))
ls(environment(square))
get(foo,environment(cube))
get(n,environment(cube))
get(y,environment(cube))
ls(environment(square))
ls(environment(cube))
get(y,environment(cube))
n <- 10
f <- function(x) {
n<- 2
n^2 + g(x)
}
g <- function(no) {
no*2
}
f(2)
f(3)
f
f(n)
n
POSIZct
POSIXct
x <- as.Date("01-01-1990")
x
unclass(x)
x <- as.Date("1990-01-01")
x
unclass(x)
weekdays(2)
weekdays(2,2)
weekdays(2,"TU")
wee
.
Sys.time()
x <- Sys.time()
y <- as.POSIXlt(x)
unclass(y)
y$sec
?strptime
cube <- function(x,y) {
x^3
}
cube(3)
x<- 1:10
if(x > 5) {
x <- 0
}
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
z <- 10
f(3)
x<- 5
y <- if(x < 5 ) {}
x<-5
y <- if(x<5){
NA
}
else {
10
}
x<-5
y <- if(x<5){
NA
}
else {
10
}
y <- if(x<5) {
NA
} else {
10
}
y
help("environment")
ls(environment())
x <- 1:10
if(x > 5) {x<-0}
help("parent.frame")
library(datasets)
data("iris")
?iris
mean(Sepal.Length)
mean('Sepal.Length')
mean(iris, 'Sepal.Length')
mean(iris$Sepal.Length)
apply(iris, 1, mean)
apply(iris[, 1:4], 1, mean)
apply(iris[, 1:4], 2, mean)
apply(iris, 2, mean)
library(datasets)
data(mtcars)
?mtcars
tapply(mtcars$mpg, mtcars$cyl, mean)
tapply(mtcars$cyl, mtcars$mpg, mean)
sapply(mtcars, cyl, mean)
library(datasets)
data("iris")
mean(iris[iris$Species == "virginica"]$Sepal.Length )
mean(iris[iris$Species == "virginica",]$Sepal.Length )
library(datasets)
data(mtcars)
mean(mtcars[mtcars$cyl == '4',]$hp, mtcars[mtcars$cyl == '8',]$hp)
mean(mtcars[mtcars$cyl == '4',]$hp - mtcars[mtcars$cyl == '8',]$hp)
mean(mtcars[mtcars$cyl == '4',]$hp) - mean(mtcars[mtcars$cyl == '8',]$hp)
mean(mtcars[mtcars$cyl == '8',]$hp) - mean(mtcars[mtcars$cyl == '4',]$hp)
debug(ls)
ls
ls
corr
ls
ls
debug()
debug
deb
ls
debug(ls)
ls
setwd("/coursera/PracticalMachineLearning")
library(caret)
install.packages("caret", dependencies = c("Depends", "Suggests"))
library(caret)
library(caret , dep = TRUE)
library(caret , dependencies = TRUE)
install.packages("ggplot2", dependencies = c("Depends", "Suggests"))
library(caret , dependencies = TRUE)
library(caret)
library(caret)
library(ggplot2)
library(gtable)
sessionInfo()
install.packages(c("ggplot2","gtable"))
library(ggplot2)
install.packages("gtable")
library(caret)
install.packages("caret", dependencies = c("Depends", "Suggests"))
install.packages("ggplot2", dependencies = c("Depends", "Suggests"))
install.packages("gtable", dependencies = c("Depends", "Suggests"))
library(caret)
install.packages("stringr", dependencies = c("Depends", "Suggests"))
library(caret)
install.packages("stringi", dependencies = c("Depends", "Suggests"))
library(caret)
install.packages("magrittr", dependencies = c("Depends", "Suggests"))
library(caret)
install.packages("munsell", dependencies = c("Depends", "Suggests"))
library(caret)
install.packages("BradleyTerry2", dependencies = c("Depends", "Suggests"))
library(caret)
library(ggplot2)
library(caret)
library(caret)
trainingRaw <- read.csv(file="pml-training.csv", header=TRUE, as.is = TRUE, stringsAsFactors = FALSE, sep=',', na.strings=c('NA','','#DIV/0!'))
trainingRaw <- read.csv(file="data/pml-training.csv", header=TRUE, as.is = TRUE, stringsAsFactors = FALSE, sep=',', na.strings=c('NA','','#DIV/0!'))
trainingRaw
source('/coursera/PracticalMachineLearning/pml-model.R', echo=TRUE)
trainingRaw <- read.csv(file="data/pml-training.csv", header=TRUE, as.is = TRUE, stringsAsFactors = FALSE, sep=',', na.strings=c('NA','','#DIV/0!'))pml-training
source('/coursera/PracticalMachineLearning/pml-model.R')
testData <- read.csv("data/pml-testing.csv", header=TRUE, as.is = TRUE, na.strings = c('NA','','#DIV/0!'))
testData
help("createDataPartition")
source('/coursera/PracticalMachineLearning/pml-model.R')
source('/coursera/PracticalMachineLearning/pml-model.R')
source('/coursera/PracticalMachineLearning/pml-model.R')
inTrain <- createDataPartition(trainingData$classe, p=0.75, list = FALSE)
inTrain
source('/coursera/PracticalMachineLearning/pml-model.R')
trainingSet
source('/coursera/PracticalMachineLearning/pml-model.R')
testSet
source('/coursera/PracticalMachineLearning/pml-model.R')
head(trainingSet)
library(AppliedPredictiveModeling)
install.packages("AppliedPredictiveModeling", dependencies = c("Depends", "Suggests"))
library(AppliedPredictiveModeling)
install.packages("CORElearn", dependencies = c("Depends", "Suggests"))
library(AppliedPredictiveModeling)
data("concrete")
library(caret)
set.seed(100)
set.seed(1000)
inTrain = createDataPartition(mixtures$CompressiveStrength, p = 3/4)[[1]]
training = mixtures[ inTrain,]
testing = mixtures[-inTrain,]
head(training)
setwd("/coursera/PracticalMachineLearning")
source('/coursera/PracticalMachineLearning/Q3.R')
head(training)
source('/coursera/PracticalMachineLearning/Q3.R')
preProc$rotation
source('/coursera/PracticalMachineLearning/Q3.R')
ILpredictors
source('/coursera/PracticalMachineLearning/Q3.R')
acc1 <- C1$overall[1]
source('/coursera/PracticalMachineLearning/Q3.R')
acc1
acc1
source('/coursera/PracticalMachineLearning/Q3.R')
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
IL <- grep('^IL', colnames(training),value=TRUE )
ILpredictors <- predictors[, IL]
df <- data.frame(diagnosis, ILpredictors)
inTrain = createDataPartition(df$diagnosis, p = 3/4)[[1]]
training = df[ inTrain,]
testing = df[-inTrain,]
modelFit <- train(diagnosis ~ ., method="glm", data=training)
predictions <- predict(modelFit, newdata=testing)
C1 <- confusionMatrix(predictions, testing$diagnosis)
print(C1)
acc1 <- C1$overall[1]
acc1
modelFit <- train(training$diagnosis ~ .,
method="glm",
preProcess="pca",
data=training,
trControl=trainControl(preProcOptions=list(thresh=0.8)))
C2 <- confusionMatrix(testing$diagnosis, predict(modelFit, testing))
print(C2)
acc2 <- C2$overall[1]
acc2
method="glm",
preProcess="pca",
acc1
acc2
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
set.seed(3433)
IL <- grep('^IL', colnames(training),value=TRUE )
ILpredictors <- predictors[, IL]
df <- data.frame(diagnosis, ILpredictors)
inTrain = createDataPartition(df$diagnosis, p = 3/4)[[1]]
training = df[ inTrain,]
testing = df[-inTrain,]
modelFit <- train(diagnosis ~ ., method="glm", data=training)
predictions <- predict(modelFit, newdata=testing)
C1 <- confusionMatrix(predictions, testing$diagnosis)
print(C1)
acc1 <- C1$overall[1]
acc1
modelFit <- train(training$diagnosis ~ .,
method="glm",
preProcess="pca",
data=training,
trControl=trainControl(preProcOptions=list(thresh=0.8)))
C2 <- confusionMatrix(testing$diagnosis, predict(modelFit, testing))
print(C2)
acc2 <- C2$overall[1]
acc2
source('/coursera/PracticalMachineLearning/Q3.R')
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
set.seed(3433)
IL <- grep('^IL', colnames(training),value=TRUE )
ILpredictors <- predictors[, IL]
df <- data.frame(diagnosis, ILpredictors)
inTrain = createDataPartition(df$diagnosis, p = 3/4)[[1]]
training = df[ inTrain,]
testing = df[-inTrain,]
modelFit <- train(diagnosis ~ ., method="glm", data=training)
predictions <- predict(modelFit, newdata=testing)
C1 <- confusionMatrix(predictions, testing$diagnosis)
print(C1)
acc1 <- C1$overall[1]
acc1
modelFit <- train(training$diagnosis ~ .,
method="glm",
preProcess="pca",
data=training,
trControl=trainControl(preProcOptions=list(thresh=0.8)))
C2 <- confusionMatrix(testing$diagnosis, predict(modelFit, testing))
print(C2)
acc2 <- C2$overall[1]
acc2
source('/coursera/PracticalMachineLearning/pml-model.R')
## Author - Madhu Balaji
library(AppliedPredictiveModeling)
library(caret)
trainingData <- read.csv("data/pml-training.csv", header=TRUE, as.is = TRUE, na.strings = c('NA','','#DIV/0!'))
testData <- read.csv("data/pml-testing.csv", header=TRUE, as.is = TRUE, na.strings = c('NA','','#DIV/0!'))
dim(trainingData)
dim(testData)
#inTrain <- createDataPartition(trainingData$classe, p=0.75, list = FALSE)
#trainingSet <- trainingData[inTrain,]
#testSet <- trainingData[-inTrain,]
#head(trainingSet)
library(AppliedPredictiveModeling)
data(segmentationOriginal)
library(caret)
source('/coursera/ML/Q4.R')
source('/coursera/ML/Q4.R')
trainingData <- subset(segmentationOriginal$Case, case == "Train")
source('/coursera/ML/Q4.R')
source('/coursera/ML/Q4.R')
source('/coursera/ML/Q4.R')
source('/coursera/ML/Q4.R')
library(AppliedPredictiveModeling)
data(segmentationOriginal)
library(caret)
library(rpart)
set.seed(125)
inTrain <- createDataPartition(y = segmentationOriginal$Case, list = FALSE)
trainingData <- segmentationOriginal[segmentationOriginal$Case== "Train",]
testingData <- segmentationOriginal[segmentationOriginal$Case== "Test",]
modFit <- train(Class ~ ., data = trainingData, method = "rpart")
modFit$finalModel
plot(modFit$finalModel, uniform = TRUE, main = "Classification Tree")
text(modFit$finalModel, use.n = TRUE, all = TRUE, cex = .8)
fancyRpartPlot(modFit$finalModel)
fancyRpartPlot(modFit)
predict(modFit, newdata = train)
library(rpart)
library(rattle)
install.packages("rattle", dependencies = c("Depends", "Suggests"))
library(rattle)
install.packages("rattle")
library(rattle)
